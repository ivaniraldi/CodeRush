CodeRush

### **Flujo Completo de la Aplicación: "CodeRush"**

Este flujo describe cómo interactúan las distintas partes de la aplicación: **Cliente (Frontend)**, **API (Backend)** y **Base de Datos (DB)**. La aplicación "CodeRush" está diseñada para ofrecer un juego competitivo de preguntas y respuestas sobre programación web entre dos jugadores, con un sistema de autenticación, seguimiento de puntajes y estadísticas.

### **1. Flujo de Usuario: Frontend (Cliente)**

El cliente es la interfaz con la que los usuarios interactúan. La aplicación de frontend está construida con **React** y se comunica con la API para realizar operaciones sobre los datos. A continuación, se explica el flujo general de las operaciones que un usuario puede realizar desde el cliente:

#### **Pantallas Principales del Cliente**

1. **Pantalla de Inicio (Home)**
   - El usuario accede a la pantalla principal de la aplicación.
   - Desde aquí, el usuario puede acceder a otras vistas: inicio de sesión, registro, listado de tests disponibles, etc.

2. **Pantalla de Registro/Login**
   - Si el usuario no está autenticado, puede registrarse o iniciar sesión.
   - **Login**: El usuario ingresa su correo y contraseña. La contraseña se valida en la API.
   - **Registro**: Se capturan los datos del usuario (nombre, correo, contraseña) y se crea una nueva cuenta.

3. **Pantalla de Selección de Test**
   - Una vez autenticado, el usuario puede ver una lista de tests disponibles (públicos o privados si es administrador).
   - Aquí también puede seleccionar un test para iniciar el juego.

4. **Pantalla de Juego (Competencia)**
   - Dos usuarios entran en la competencia, cada uno recibe 5 preguntas de forma aleatoria.
   - El jugador debe responder correctamente y lo más rápido posible. Se calcula el puntaje de acuerdo al tiempo y precisión.
   - Los jugadores pueden ver las respuestas y el puntaje en tiempo real.

5. **Pantalla de Resultados**
   - Al finalizar el juego, los resultados se muestran. Los puntajes obtenidos se almacenan en la base de datos.
   - También se permite ver los mejores puntajes (highscores) y el perfil del usuario.

6. **Pantalla de Perfil**
   - El usuario puede ver sus estadísticas: cantidad de juegos jugados, victorias, derrotas, puntaje total, tiempo promedio de respuesta, etc.

---

### **2. Flujo de la API (Backend)**

El backend se encarga de gestionar las solicitudes del cliente, interactuar con la base de datos y devolver los resultados correspondientes. El backend está construido con **Node.js** usando **Express** y utiliza **Socket.io** para la comunicación en tiempo real entre jugadores durante el juego.

#### **Operaciones de la API**

1. **Autenticación y Gestión de Usuarios**
   - **Registro de Usuario**: La API recibe los datos del usuario desde el frontend y los inserta en la base de datos, encriptando la contraseña con **bcrypt.js**.
   - **Inicio de Sesión**: El usuario ingresa su correo y contraseña, la API valida los datos con bcrypt y genera un **JSON Web Token (JWT)** para la autenticación.
   - **Autenticación de Rutas Privadas**: Se usa JWT para validar las rutas privadas de la API. Si el token es válido, el usuario tiene acceso; de lo contrario, se le redirige al login.

2. **Creación de Tests y Preguntas**
   - **Creación de Test**: Los administradores pueden crear nuevos tests, asignarles una categoría y visibilidad (público o privado). Se almacenan en la tabla **Tests**.
   - **Creación de Preguntas**: El administrador puede agregar preguntas, junto con sus respuestas correctas e incorrectas, asociándolas a un test específico.

3. **Gestión de Respuestas y Puntajes**
   - **Respuestas del Jugador**: Cuando un jugador responde, la API guarda la respuesta, el tiempo de respuesta y calcula el puntaje basado en la rapidez y corrección de la respuesta.
   - **Cálculo del Puntaje**: La API calcula el puntaje total al finalizar el juego y lo guarda en la tabla **Highscores**.

4. **Gestión de Juegos**
   - **Inicio de Juego**: Se inicia una nueva partida entre dos jugadores y se asignan preguntas aleatorias. La API guarda el estado del juego en la tabla **Games**.
   - **Finalización de Juego**: Al concluir, la API actualiza el estado del juego y registra los puntajes en la tabla **Highscores**.

5. **Estadísticas del Perfil**
   - **Actualizar Estadísticas**: Después de cada juego, la API actualiza las estadísticas del jugador (respuestas correctas, promedio de tiempo de respuesta, victorias y derrotas) en la tabla **Profile_Stats**.

---

### **3. Flujo de la Base de Datos (DB)**

La base de datos es la que almacena toda la información relevante para la aplicación: usuarios, tests, preguntas, respuestas, puntajes, juegos y estadísticas del perfil.

#### **Estructura y Relaciones**

1. **Users**
   - Contiene los datos de los usuarios, incluyendo su nombre, correo, contraseña y puntaje total.
   - Relación con **Highscores** (uno a muchos) y **Profile_Stats** (uno a uno).
   
2. **Tests**
   - Contiene los datos de los tests creados por los administradores (nombre, categoría y visibilidad).
   - Relación con **Questions** (uno a muchos).

3. **Questions**
   - Contiene las preguntas de cada test, incluyendo el texto de la pregunta y sus respuestas posibles.
   - Relación con **Answers** (uno a muchos) y **Tests** (uno a muchos).

4. **Answers**
   - Almacena las respuestas de los jugadores a las preguntas.
   - Relación con **Users** (uno a muchos) y **Questions** (uno a muchos).

5. **Highscores**
   - Almacena los puntajes de los jugadores después de cada partida.
   - Relación con **Users** (uno a muchos).

6. **Games**
   - Registra el inicio y finalización de cada partida entre dos jugadores.
   - Relación con **Users** (uno a muchos) y **Highscores** (uno a muchos).

7. **Profile_Stats**
   - Almacena estadísticas del jugador, como el tiempo promedio de respuesta, respuestas correctas, juegos jugados, victorias y derrotas.
   - Relación con **Users** (uno a uno).

#### **Relaciones Complejas en la DB**

- Un **usuario** puede tener múltiples **respuestas** (en **Answers**).
- Un **test** puede tener múltiples **preguntas** (en **Questions**).
- Un **juego** puede involucrar a dos jugadores, con un **puntaje** registrado en **Highscores**.
- Un **jugador** puede tener estadísticas completas almacenadas en **Profile_Stats**, que se actualizan con cada juego.

---

### **Resumen del Flujo de la Aplicación**

1. **Frontend** (React) interactúa con el **Backend** (Node.js + Express) a través de API REST (y WebSockets para comunicación en tiempo real).
   - El cliente envía solicitudes para iniciar sesión, jugar, registrar respuestas y ver resultados.
   
2. **Backend** valida la autenticación, maneja la lógica de negocio, y realiza las operaciones necesarias en la base de datos (inserción de datos, actualizaciones de puntajes, cálculo de estadísticas, etc.).

3. **Base de Datos** (PostgreSQL) guarda toda la información relevante, desde los datos de los usuarios hasta los resultados de los juegos y estadísticas del perfil.

Este flujo asegura una experiencia de usuario eficiente y segura, aprovechando un sistema de autenticación robusto (JWT), cálculos de puntajes en tiempo real, y estadísticas completas para los jugadores.

Dependencias
Frontend:
1. React
2. React Router Dom
3. Axios
4. Socket.io-client
5. Context API
6. Tailwind CSS
7. React-Query
8. React-icons
Backend:
1. JWT (JSON Web Tokens)
2. Bcrypt.js
3. Multer
4. Socket.io (Server)
5. Express
6. PostgreSQL (pg)
7. pg-format



Diseño de la interfaz gráfica (Boceto)
Pantallas principales:

Pantalla de inicio (Home):

Título del juego.
Botón para iniciar sesión (redirige a la pantalla de login).
Botón para ver el leaderboard.
Botón para ver los tests disponibles (públicos).
Pantalla de inicio de sesión (Login):

Formulario para ingresar el correo y la contraseña.
Opción para registrarse.
Botón para "Iniciar sesión".
Pantalla de registro (Sign Up):

Formulario para crear cuenta (nombre, correo, contraseña, confirmación de contraseña).
Botón de "Registrarse".
Pantalla de juego (Game):

Muestra la pregunta actual (texto o imagen de código).
Botones para responder.
Temporizador para mostrar el tiempo restante de la ronda.
Puntuación y nombre del jugador.
Zona para el puntaje total del juego.
Pantalla de leaderboard (Highscores):

Tabla con los mejores puntajes.
Nombre de usuario, puntaje, y fecha del mejor puntaje.
Pantalla de administrador (Admin Panel):

Panel donde el administrador puede crear tests (título, categoría, visibilidad, etc.).
Crear preguntas (texto o imágenes de código).
Botones para gestionar los tests públicos y privados.


1. Diseño de la interfaz gráfica (Boceto actualizado)
Pantallas principales:

Pantalla de inicio (Home):

Título del juego.
Botón para iniciar sesión (redirige a la pantalla de login).
Botón para ver el leaderboard.
Botón para ver los tests disponibles (públicos).
Pantalla de inicio de sesión (Login):

Formulario para ingresar el correo y la contraseña.
Opción para registrarse.
Botón para "Iniciar sesión".
Pantalla de registro (Sign Up):

Formulario para crear cuenta (nombre, correo, contraseña, confirmación de contraseña).
Botón de "Registrarse".
Pantalla de juego (Game):

Muestra la pregunta actual (texto o imagen de código).
Botones para responder.
Temporizador para mostrar el tiempo restante de la ronda.
Puntuación y nombre del jugador.
Zona para el puntaje total del juego.
Pantalla de leaderboard (Highscores):

Tabla con los mejores puntajes.
Nombre de usuario, puntaje, y fecha del mejor puntaje.
Pantalla de perfil del usuario (Profile):

Nombre del usuario.
Últimos resultados de los tests jugados (puntuaciones).
Historial de puntajes en partidas anteriores.
Estadísticas del usuario (promedio de respuestas correctas, tiempos, etc.).
Botón para editar perfil (opcional).
Pantalla de administrador (Admin Panel):

Panel donde el administrador puede crear tests (título, categoría, visibilidad, etc.).
Crear preguntas (texto o imágenes de código).
Botones para gestionar los tests públicos y privados.
2. Definición de la navegación entre las vistas (con vista de perfil)
Vistas públicas:

Inicio (/)
Registro (/signup)
Inicio de sesión (/login)
Leaderboard (/highscores)
Tests públicos (/tests)

Vistas privadas (requieren login):

Pantalla de juego (/game)
Panel de administración (/admin)
Perfil de usuario (/profile)


Tablas y Tipos de Datos
1. Users
id: SERIAL PRIMARY KEY
(Identificador único para el usuario)
name: VARCHAR(255)
(Nombre del usuario)
email: VARCHAR(255) UNIQUE
(Correo electrónico del usuario)
password: VARCHAR(255)
(Contraseña encriptada)
total_points: INTEGER DEFAULT 0
(Puntaje total acumulado del usuario)

2. Tests
id: SERIAL PRIMARY KEY
(Identificador único para el test)
name: VARCHAR(255)
(Nombre del test)
category: VARCHAR(255)
(Categoría del test, por ejemplo: JavaScript, CSS, etc.)
visibility: ENUM('public', 'private')
(Visibilidad del test: público o privado)

3. Questions
id: SERIAL PRIMARY KEY
(Identificador único para la pregunta)
test_id: INTEGER REFERENCES Tests(id)
(Clave foránea que apunta a la tabla de Tests)
question_text: TEXT
(Texto de la pregunta)
image_url: TEXT (opcional)
(URL de la imagen de código, si la pregunta es visual)
correct_answer: TEXT
(Respuesta correcta)
wrong_answer_1: TEXT
(Respuesta incorrecta 1)
wrong_answer_2: TEXT
(Respuesta incorrecta 2)
wrong_answer_3: TEXT
(Respuesta incorrecta 3)

4. Answers
id: SERIAL PRIMARY KEY
(Identificador único para la respuesta)
user_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al usuario)
question_id: INTEGER REFERENCES Questions(id)
(Clave foránea que apunta a la pregunta)
answer: TEXT
(Respuesta dada por el usuario)
response_time: INTEGER
(Tiempo en milisegundos en el que el usuario respondió)

5. Highscores
id: SERIAL PRIMARY KEY
(Identificador único para el puntaje)
user_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al usuario)
score: INTEGER
(Puntaje obtenido)
date: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
(Fecha en la que se logró el puntaje)

6. Games
id: SERIAL PRIMARY KEY
(Identificador único para la partida)
player_1_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al primer jugador)
player_2_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al segundo jugador)
game_status: ENUM('pending', 'in_progress', 'finished')
(Estado de la partida: pendiente, en progreso, finalizada)
start_time: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
(Hora de inicio de la partida)
end_time: TIMESTAMP (opcional)
(Hora de finalización de la partida)

7. Profile_Stats
(Para almacenar estadísticas relacionadas con el perfil del usuario)

id: SERIAL PRIMARY KEY
(Identificador único para las estadísticas del perfil)
user_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al usuario)
average_time: INTEGER
(Promedio de tiempo de respuesta en segundos)
correct_answers: INTEGER
(Número de respuestas correctas del usuario)
total_played_games: INTEGER
(Número total de juegos jugados por el usuario)
total_wins: INTEGER
(Número total de partidas ganadas)
total_losses: INTEGER
(Número total de partidas perdidas)
Relaciones
Users - Games: Relación uno a muchos (Un jugador puede tener muchas partidas).
Tests - Questions: Relación uno a muchos (Un test puede tener muchas preguntas).
Users - Answers: Relación uno a muchos (Un usuario puede dar muchas respuestas).
Questions - Answers: Relación uno a muchos (Una pregunta puede tener muchas respuestas).
Users - Highscores: Relación uno a muchos (Un jugador puede tener múltiples puntajes, aunque en la práctica generalmente habrá solo uno por jugador).
Users - Profile_Stats: Relación uno a uno (Cada usuario tendrá un único conjunto de estadísticas).


Tablas y Tipos de Datos

1. Users
id: SERIAL PRIMARY KEY
(Identificador único para el usuario)
name: VARCHAR(255)
(Nombre del usuario)
email: VARCHAR(255) UNIQUE
(Correo electrónico del usuario)
password: VARCHAR(255)
(Contraseña encriptada)
total_points: INTEGER DEFAULT 0
(Puntaje total acumulado del usuario)

2. Tests
id: SERIAL PRIMARY KEY
(Identificador único para el test)
name: VARCHAR(255)
(Nombre del test)
category: VARCHAR(255)
(Categoría del test, por ejemplo: JavaScript, CSS, etc.)
visibility: ENUM('public', 'private')
(Visibilidad del test: público o privado)

3. Questions
id: SERIAL PRIMARY KEY
(Identificador único para la pregunta)
test_id: INTEGER REFERENCES Tests(id)
(Clave foránea que apunta a la tabla de Tests)
question_text: TEXT
(Texto de la pregunta)
image_url: TEXT (opcional)
(URL de la imagen de código, si la pregunta es visual)
correct_answer: TEXT
(Respuesta correcta)
wrong_answer_1: TEXT
(Respuesta incorrecta 1)
wrong_answer_2: TEXT
(Respuesta incorrecta 2)
wrong_answer_3: TEXT
(Respuesta incorrecta 3)

4. Answers
id: SERIAL PRIMARY KEY
(Identificador único para la respuesta)
user_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al usuario)
question_id: INTEGER REFERENCES Questions(id)
(Clave foránea que apunta a la pregunta)
answer: TEXT
(Respuesta dada por el usuario)
response_time: INTEGER
(Tiempo en milisegundos en el que el usuario respondió)

5. Highscores
id: SERIAL PRIMARY KEY
(Identificador único para el puntaje)
user_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al usuario)
score: INTEGER
(Puntaje obtenido)
date: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
(Fecha en la que se logró el puntaje)

6. Games
id: SERIAL PRIMARY KEY
(Identificador único para la partida)
player_1_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al primer jugador)
player_2_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al segundo jugador)
game_status: ENUM('pending', 'in_progress', 'finished')
(Estado de la partida: pendiente, en progreso, finalizada)
start_time: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
(Hora de inicio de la partida)
end_time: TIMESTAMP (opcional)
(Hora de finalización de la partida)

7. Profile_Stats
(Para almacenar estadísticas relacionadas con el perfil del usuario)
id: SERIAL PRIMARY KEY
(Identificador único para las estadísticas del perfil)
user_id: INTEGER REFERENCES Users(id)
(Clave foránea que apunta al usuario)
average_time: INTEGER
(Promedio de tiempo de respuesta en segundos)
correct_answers: INTEGER
(Número de respuestas correctas del usuario)
total_played_games: INTEGER
(Número total de juegos jugados por el usuario)
total_wins: INTEGER
(Número total de partidas ganadas)
total_losses: INTEGER
(Número total de partidas perdidas)

Relaciones
Users - Games: Relación uno a muchos (Un jugador puede tener muchas partidas).
Tests - Questions: Relación uno a muchos (Un test puede tener muchas preguntas).
Users - Answers: Relación uno a muchos (Un usuario puede dar muchas respuestas).
Questions - Answers: Relación uno a muchos (Una pregunta puede tener muchas respuestas).
Users - Highscores: Relación uno a muchos (Un jugador puede tener múltiples puntajes, aunque en la práctica generalmente habrá solo uno por jugador).
Users - Profile_Stats: Relación uno a uno (Cada usuario tendrá un único conjunto de estadísticas).


El flujo (o *flow*) de la base de datos en tu aplicación **CodeRush** sigue una estructura lógica donde las tablas están interconectadas para manejar las funcionalidades del juego, como el registro de usuarios, la creación de tests, la participación en partidas, y el seguimiento de las estadísticas de los jugadores. A continuación te explico cómo interactúan las tablas y qué datos se gestionan en cada paso del proceso.

### 1. **Registro e inicio de sesión de usuario (Tabla `Users`)**
   - **Proceso**: Los usuarios se registran con un nombre, correo electrónico y contraseña. La contraseña se encripta antes de guardarse en la base de datos.
   - **Flujo**: Cuando un usuario se registra o inicia sesión, se verifica su existencia en la tabla `Users`. Si el correo ya existe, se autentica su contraseña. Si no, se crea una nueva entrada.
   - **Interacción**: 
     - **Usuario** -> `Users` (Insertar nuevo usuario o verificar si existe).

### 2. **Creación y visualización de Tests (Tabla `Tests`)**
   - **Proceso**: Los administradores pueden crear tests, asignarles una categoría, y elegir si el test será público o privado.
   - **Flujo**: Los tests se insertan en la tabla `Tests` con la visibilidad configurada. Los tests públicos pueden ser accedidos por cualquier usuario, mientras que los privados solo pueden ser jugados por usuarios autorizados.
   - **Interacción**: 
     - **Administrador** -> `Tests` (Crear nuevo test).

### 3. **Creación de Preguntas para los Tests (Tabla `Questions`)**
   - **Proceso**: Cada test tiene preguntas asociadas. Las preguntas contienen un texto de pregunta, imágenes opcionales y múltiples respuestas (una correcta y tres incorrectas).
   - **Flujo**: Cuando un administrador crea un test, puede agregarle preguntas. Estas preguntas se insertan en la tabla `Questions` y se asocian al test a través del campo `test_id`.
   - **Interacción**: 
     - **Administrador** -> `Questions` (Agregar preguntas a un test).

### 4. **Respuestas de los Jugadores (Tabla `Answers`)**
   - **Proceso**: Los jugadores juegan el test y responden a las preguntas. Cada respuesta está vinculada a una pregunta específica y un jugador.
   - **Flujo**: Las respuestas de los jugadores se almacenan en la tabla `Answers`, con los detalles de la respuesta dada, el tiempo en que fue respondida y las relaciones con la pregunta y el jugador.
   - **Interacción**: 
     - **Jugador** -> `Answers` (Guardar las respuestas del jugador).

### 5. **Puntajes más altos (Tabla `Highscores`)**
   - **Proceso**: Después de completar un test o una serie de preguntas, se calcula el puntaje del jugador (basado en la cantidad de respuestas correctas y su velocidad).
   - **Flujo**: El puntaje se guarda en la tabla `Highscores`, junto con el `user_id` para saber qué jugador logró ese puntaje. También se guarda la fecha en que se obtuvo.
   - **Interacción**: 
     - **Sistema de puntajes** -> `Highscores` (Guardar puntajes de los jugadores).

### 6. **Juegos (Tabla `Games`)**
   - **Proceso**: Dos jugadores se enfrentan en una partida, donde compiten para ver quién responde más rápido y correctamente.
   - **Flujo**: Cuando dos jugadores comienzan un juego, se crea una nueva entrada en la tabla `Games` con el estado `pending` (pendiente). Luego, el juego puede avanzar a `in_progress` (en progreso) y, finalmente, a `finished` (finalizado).
   - **Interacción**:
     - **Jugador 1 y Jugador 2** -> `Games` (Crear nueva partida).
     - **Sistema** -> `Games` (Actualizar estado del juego).

### 7. **Estadísticas del Perfil del Jugador (Tabla `Profile_Stats`)**
   - **Proceso**: Cada jugador tiene estadísticas que incluyen el promedio de tiempo de respuesta, número de respuestas correctas, juegos jugados, victorias y derrotas.
   - **Flujo**: A medida que el jugador participa en partidas y responde preguntas, sus estadísticas se actualizan en la tabla `Profile_Stats`. Esta tabla tiene una relación 1 a 1 con el jugador, por lo que solo existe un conjunto de estadísticas por usuario.
   - **Interacción**: 
     - **Sistema** -> `Profile_Stats` (Actualizar estadísticas del jugador).

### 8. **Interacciones y Relaciones entre Tablas**
   - **`Users` -> `Games`**: Cada jugador puede tener múltiples juegos. Un juego puede involucrar a dos jugadores, pero siempre está vinculado a los jugadores mediante `player_1_id` y `player_2_id`.
   - **`Tests` -> `Questions`**: Cada test puede tener múltiples preguntas. Las preguntas se asocian a un test a través del campo `test_id`.
   - **`Questions` -> `Answers`**: Cada pregunta puede tener múltiples respuestas, las cuales están vinculadas a la pregunta mediante el campo `question_id`.
   - **`Users` -> `Answers`**: Cada jugador puede dar muchas respuestas, las cuales están vinculadas a un usuario específico mediante el campo `user_id`.
   - **`Users` -> `Highscores`**: Un jugador puede tener múltiples puntajes a lo largo del tiempo, pero generalmente, solo el último puntaje se considera como el más relevante.
   - **`Users` -> `Profile_Stats`**: Cada usuario tiene un único conjunto de estadísticas de perfil, lo que se refleja en la relación uno a uno entre las tablas `Users` y `Profile_Stats`.

### **Flujo Completo de una Sesión de Juego:**

1. **Registro de Usuario**: Un usuario se registra en el sistema y se guarda en la tabla `Users`.
2. **Selección de Test**: El jugador elige un test (de los públicos o privados) desde la tabla `Tests`.
3. **Respuestas a Preguntas**: El jugador responde preguntas del test, y las respuestas se guardan en la tabla `Answers` junto con el tiempo de respuesta.
4. **Cálculo de Puntaje**: Al finalizar el test, el puntaje del jugador se calcula y se guarda en la tabla `Highscores`.
5. **Juego en Pareja**: Los jugadores pueden jugar contra otro usuario. Los detalles del juego (como los jugadores involucrados y el estado del juego) se guardan en la tabla `Games`.
6. **Estadísticas del Perfil**: Los datos como el tiempo promedio de respuesta y las victorias se actualizan en la tabla `Profile_Stats` del jugador.

### **Resumen del Flujo de la DB:**
El flujo de la base de datos está diseñado para gestionar la información de usuarios, los tests, las preguntas, las respuestas, los puntajes, las partidas y las estadísticas. Cada entidad interactúa con otras de manera clara, asegurando la integridad de los datos y la correcta gestión del juego y la competencia entre jugadores.

Aquí tienes un conjunto de consultas SQL para interactuar con la base de datos en cada uno de los pasos del flujo de **CodeRush**. Las consultas abarcan operaciones de lectura y escritura en varias tablas para realizar las acciones descritas en el flujo.

### 1. **Registro de Usuario**
Cuando un nuevo usuario se registra, se inserta su información en la tabla `Users`.

#### Consulta para registrar un nuevo usuario:
```sql
INSERT INTO Users (name, email, password)
VALUES ('Juan Pérez', 'juanperez@example.com', 'hashed_password');
```

#### Consulta para verificar si el correo electrónico ya está registrado:
```sql
SELECT * FROM Users WHERE email = 'juanperez@example.com';
```

### 2. **Inicio de Sesión de Usuario**
Cuando un usuario inicia sesión, se valida su correo y contraseña, y se obtiene su información básica.

#### Consulta para obtener los datos del usuario durante el inicio de sesión:
```sql
SELECT * FROM Users WHERE email = 'juanperez@example.com' AND password = 'hashed_password';
```

### 3. **Creación de un Test (Administrador)**
El administrador puede crear un nuevo test y definir su visibilidad.

#### Consulta para crear un nuevo test:
```sql
INSERT INTO Tests (name, category, visibility)
VALUES ('JavaScript Basics', 'JavaScript', 'public');
```

#### Consulta para obtener los tests disponibles (públicos o privados):
```sql
SELECT * FROM Tests WHERE visibility = 'public';
```

### 4. **Creación de Preguntas para el Test**
El administrador agrega preguntas a un test específico. Cada pregunta tiene múltiples respuestas.

#### Consulta para agregar una nueva pregunta con sus respuestas:
```sql
INSERT INTO Questions (test_id, question_text, image_url, correct_answer, wrong_answer_1, wrong_answer_2, wrong_answer_3)
VALUES (1, '¿Cuál es el operador para la igualdad en JavaScript?', NULL, '==', '=', '===', '!==');
```

#### Consulta para obtener las preguntas de un test específico:
```sql
SELECT * FROM Questions WHERE test_id = 1;
```

### 5. **Respuestas de los Jugadores**
Cuando un jugador responde a una pregunta, su respuesta se guarda en la tabla `Answers`, junto con el tiempo de respuesta.

#### Consulta para insertar una respuesta del jugador:
```sql
INSERT INTO Answers (user_id, question_id, answer, response_time)
VALUES (1, 1, '==', 500);
```

#### Consulta para obtener todas las respuestas de un jugador:
```sql
SELECT * FROM Answers WHERE user_id = 1;
```

### 6. **Cálculo del Puntaje y Registro en Highscores**
Después de que el jugador termine el test, calculamos el puntaje (en función de las respuestas correctas y su tiempo) y lo almacenamos en la tabla `Highscores`.

#### Consulta para insertar el puntaje del jugador:
```sql
INSERT INTO Highscores (user_id, score, date)
VALUES (1, 100, CURRENT_TIMESTAMP);
```

#### Consulta para obtener los puntajes más altos:
```sql
SELECT u.name, h.score, h.date
FROM Highscores h
JOIN Users u ON h.user_id = u.id
ORDER BY h.score DESC
LIMIT 10;
```

### 7. **Inicio de una Nueva Partida (Juego entre 2 jugadores)**
Cuando dos jugadores se enfrentan en una partida, se crea una nueva entrada en la tabla `Games`.

#### Consulta para crear una nueva partida entre dos jugadores:
```sql
INSERT INTO Games (player_1_id, player_2_id, game_status)
VALUES (1, 2, 'pending');
```

#### Consulta para obtener las partidas en progreso:
```sql
SELECT * FROM Games WHERE game_status = 'in_progress';
```

### 8. **Actualizar el Estado del Juego**
A medida que el juego avanza, el estado se actualiza. Por ejemplo, cuando la partida termina, se actualiza el estado a `finished`.

#### Consulta para actualizar el estado de una partida:
```sql
UPDATE Games
SET game_status = 'finished', end_time = CURRENT_TIMESTAMP
WHERE id = 1;
```

### 9. **Estadísticas del Perfil del Jugador**
A medida que el jugador juega, sus estadísticas de perfil (como el promedio de tiempo de respuesta, respuestas correctas, etc.) se actualizan.

#### Consulta para insertar o actualizar estadísticas del perfil del jugador:
```sql
INSERT INTO Profile_Stats (user_id, average_time, correct_answers, total_played_games, total_wins, total_losses)
VALUES (1, 10, 50, 20, 15, 5)
ON CONFLICT (user_id) DO UPDATE
SET average_time = 10,
    correct_answers = 50,
    total_played_games = 20,
    total_wins = 15,
    total_losses = 5;
```

#### Consulta para obtener las estadísticas de un jugador:
```sql
SELECT * FROM Profile_Stats WHERE user_id = 1;
```

### Consultas Avanzadas para Relacionar Múltiples Tablas

#### Obtener todas las respuestas de un jugador junto con las preguntas:
```sql
SELECT q.question_text, a.answer, a.response_time
FROM Answers a
JOIN Questions q ON a.question_id = q.id
WHERE a.user_id = 1;
```

#### Obtener todas las partidas de un jugador con el puntaje más alto de cada juego:
```sql
SELECT g.id, g.game_status, h.score
FROM Games g
JOIN Highscores h ON g.id = h.game_id
WHERE g.player_1_id = 1 OR g.player_2_id = 1
ORDER BY h.score DESC;
```

#### Obtener las preguntas más respondidas por los usuarios (basado en la cantidad de respuestas):
```sql
SELECT q.question_text, COUNT(a.id) AS num_responses
FROM Questions q
JOIN Answers a ON q.id = a.question_id
GROUP BY q.id
ORDER BY num_responses DESC;
```

### **Resumen:**
Estas consultas cubren la interacción básica del usuario con el sistema, desde el registro, la creación de tests, la respuesta a preguntas, hasta el cálculo de puntajes y el seguimiento de estadísticas de perfil. Las consultas permiten realizar un flujo continuo de inserción y consulta de datos, manteniendo las relaciones entre las tablas adecuadamente.